{
    "HeapTailMarker": "Malware can detect if it's on a debug heap by checking the HeapTailMarker value. \nIf this value is ABABABAB, it indicates execution in a debug environment; otherwise, it's a normal execution.",
    "KernelDebuggerMarker": "Detect Kernelmode Debugger(KdDebuggerEnabled)",
    "DbgBreakPoint_RET": "This detection may be due to the first byte of the DbgBreakPoint function being replaced with 0xC3, which corresponds to the 'ret' instruction. \nThis prevents a debugger from successfully attaching to the process.",
    "DbgUiRemoteBreakin_Debugger_Terminate": "When a debugger tries to attach to a process, the process automatically terminates.",
    "PMCCheck_RDPMC": "The RDPMC (Read Performance-Monitoring Counters) the value of the Performance Monitoring Counter (PMC) to determine if it's being debugged.",
    "TimingCheck_RDTSC": "The RDTSC (Read Time Stamp Counter) instruction can be used to perform timing checks and may be utilized in anti-debugging techniques.",
    "SkipPrefixes_INT1":"This anti-debugging method exploits how some debuggers handle the bytes 0xF3 and 0x64 as instruction prefixes. \nThey skip the prefix and don't reach the INT1 instruction (0xF1), preventing an exception from occurring.",
    "INT2D_interrupt_check": "The INT2D instruction either passes control to a debugger or increments the EIP register's value if no debugger is active. \nThis distinguishes between debugger control or normal execution.",
    "INT3_interrupt_check": "This is a debug detection mechanism using the INT 3 instruction. \nIt utilizes the fact that if the program is being debugged, the execution does not proceed to the exception handling.",
    "EXCEPTION_BREAKPOINT": "This is a debug detection method using the INT 3 instruction. It exploits the fact that if the program is being debugged, execution does not proceed to exception handling. \nIt targets instances where the EXCEPTION_BREAKPOINT (0x80000003) is present in the code.",
    "ICE_interrupt_check": "If a program is debugged, the debugger sees the exception as standard, caused by the SingleStep bit in the flags register. \nUnder a debugger, the exception handler isn't invoked, and execution continues after the ICE instruction, indicating a debugged situation.",
    "DBG_PRINTEXCEPTION_C": "This may involve anti-debugging by utilizing the DBG_PRINTEXCEPTION_C (0x40010006) exception triggered by ntdll!DbgPrint() and kernel32!OutputDebugStringW().",
    "TrapFlag_SingleStepException": "This anti-debugging technique utilizes the Trap Flag(In binary,100000000 and in hexadecimal 100) \nand leverages the SINGLE_STEP exception to verify whether the program is being debugged.",
    "BeingDebugged_check" : "The BeingDebugged field in the Process Environment Block (PEB) indicates whether the current process is being debugged or not.",
    "NtGlobalFlag_check": "The code is checking the NtGlobalFlag value at offset 0x68 from the Process Environment Block. \nThe value 70 is the sum of FLG_HEAP_ENABLE_TAIL_CHECK (0x10), FLG_HEAP_ENABLE_FREE_CHECK (0x20), and FLG_HEAP_VALIDATE_PARAMETERS (0x40).",
    "NtGlobalFlag_check_2": "The code is checking the NtGlobalFlag value at offset 0xBC(64bit) from the Process Environment Block. \nThe value 70 is the sum of FLG_HEAP_ENABLE_TAIL_CHECK (0x10), FLG_HEAP_ENABLE_FREE_CHECK (0x20), and FLG_HEAP_VALIDATE_PARAMETERS (0x40).",
    "HeapFlags" : "HeapFlags stores various heap-related flags, bit by bit. \nThese flags include those that control certain features of the heap and those that enable debugging functions.",
    "HeapForceFlags" : "HeapForceFlags contains flags used by Windows heap management, \noften set in debugging environments, to control heap memory behavior and consistency.",
    "Combination_of_HEAP_Flags" : "This Value contains HEAP_TAIL_CHECKING_ENABLED(0x20),HEAP_FREE_CHECKING_ENABLED (0x40),HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)",
    "Combination_of_HEAP_Flags_2" : "This Value contains HEAP_GROWABLE (2),HEAP_TAIL_CHECKING_ENABLED(0x20),HEAP_FREE_CHECKING_ENABLED (0x40),HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)",
    "ReadHeapFlags" : "The code might be using RtlQueryProcessHeapInformation to check if it is in a debugged state (whether certain flags are set or not) from the heap's information.",
    "ReadHeapFlags_2" : "The code might be using RtlQueryProcessDebugInformation to check if it is in a debugged state (whether certain flags are set or not) from the heap's information.",
    "DebugPrivileges_Check" : "In a debugging environment, the privilege level may be higher, \nallowing a handle to the CSRSS process using OpenProcess with full access. Success could indicate debugging.",
    "Opened_Exclusively_Check" : "CreateFile is attempting to exclusively open its own executable file. \nIf it fails to do so, it deduces that a debugger may already have it open exclusively. If the dwShareMode argument of CreateFile is 0, this is highly likely.",
    "EXCEPTION_INVALID_HANDLE_1" : "Passing an invalid handle to kernel32!CloseHandle() with a debugger raises an EXCEPTION_INVALID_HANDLE (0xC0000008) exception. \nThis value reveals if the process is in a debugging environment.",
    "EXCEPTION_INVALID_HANDLE_2" : "Passing an invalid handle to ntdll!NtClose() with a debugger raises an EXCEPTION_INVALID_HANDLE (0xC0000008) exception. \nThis value shows if the process is in a debugging environment.",
    "Memory_EXECUTE_READWRITE_1" :"The flProtect parameter of VirtualAlloc is set to PAGE_EXECUTE_READWRITE (0x40). \nThis enables dynamic writing and execution of new code in the allocated executable memory region.",
    "Memory_EXECUTE_READWRITE_2" :"The flNewProtect parameter in VirtualProtect is configured with PAGE_EXECUTE_READWRITE (0x40). \nThis configuration permits both dynamic code insertion and execution within the targeted executable memory area.",
    "Memory_Region_Tracking" : "This refers to utilizing VirtualAlloc and GetWriteWatch to detect whether a debugger is manipulating memory in an unexpected pattern.",
    "Check_BreakPoint_Memory_1" : "The function kernel32!Toolhelp32ReadProcessMemory() reads process memory and checks for the presence of a breakpoint (0xCC).",
    "Check_BreakPoint_Memory_2" : "The memory area is examined for the presence of a breakpoint (0xCC), and its settings may have been overwritten.",
    "Software_Breakpoints_Check" : "This rule detects software breakpoints by using NtQueryVirtualMemory. It checks the current process's working set to see if a page is shared or has a share count of zero. \nSetting a software breakpoint modifies the memory page, triggering a Copy-On-Write, making the page unshared with other processes.",
    "Hardware_Breakpoints_Check" : "Check the debug registers DR0, DR1, DR2, and DR3 (CONTEXT_DEBUG_REGISTERS 0x10010) \nto determine if a hardware breakpoint has been set.",
    "Enumerate_Running_Processes" : "The CreateToolhelp32Snapshot function to enumerate running processes. \nIt might be detecting a specific debugger and using functions like ReadProcessMemory to inspect the contents of memory to determine if debugging is occurring.",
    "ThreadHideFromDebugger" : "The function NtSetInformationThread is invoked to hide the current thread from the debugger. \nAt this time, ThreadHideFromDebugger (0x11) is specified. This technique makes it more difficult for the program to be analyzed by a debugger.",
    "NtQueryInformationProcess_PDPort" : "By passing the ProcessDebugPort as an argument to NtQueryInformationProcess, it can determine whether the current process is under a debugging environment. \nIf it returns -1 (0xFFFFFFFF), it indicates that the process is being debugged.",
    "NtQueryInformationProcess_PDFlags" : "By using ProcessDebugFlags (0x1f) with NtQueryInformationProcess, the presence of a debugger can be detected. \nA return value of 0 signifies a debugging environment.",
    "NtQueryInformationProcess_PDObjectHandle" : "Using ProcessDebugObjectHandle (0x1e) with NtQueryInformationProcess obtains the debug object handle. \nIf it exists, the process is under debugger monitoring.",
    "NtQuerySystemInformation_KD_Check" : "Calling NtQuerySystemInformation with SystemKernelDebuggerInformation (0x23) returns data on the system's kernel debugger, \nindicating whether kernel debugging is enabled."
}
